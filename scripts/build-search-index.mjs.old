import fs from "fs-extra";
import path from "path";
import glob from "fast-glob";
import matter from "gray-matter";
import Fuse from "fuse.js";

const CONTENT_DIR = "content/pages/blog";
const OUTPUT_FILE = "public/search-index.json";

// ---- CONFIG ----
const CHUNK_SIZE = 800; // chars per chunk
const KEYS = [
  { name: "title", weight: 0.3 },
  { name: "text", weight: 0.7 },
];
const FUSE_OPTIONS = {
  includeScore: false,
  ignoreLocation: true,
  threshold: 0.35,
  distance: 300,
  minMatchCharLength: 3,
  useExtendedSearch: true,
  keys: KEYS,
};

// ---- HELPERS ----

// Extract all string values from a deeply nested object or array
function extractAllText(obj) {
  let result = [];
  if (typeof obj === "string") {
    result.push(obj);
  } else if (Array.isArray(obj)) {
    for (const item of obj) result.push(...extractAllText(item));
  } else if (typeof obj === "object" && obj !== null) {
    for (const v of Object.values(obj)) result.push(...extractAllText(v));
  }
  return result;
}

// Split large text blocks into manageable chunks
function chunkText(text, size = CHUNK_SIZE) {
  const clean = text
    .replace(/\r?\n+/g, " ")
    .replace(/\s+/g, " ")
    .trim();
  const chunks = [];
  for (let i = 0; i < clean.length; i += size) {
    chunks.push(clean.slice(i, i + size));
  }
  return chunks;
}

// Convert file path to slug (/blog/something)
function pathToSlug(filepath) {
  const rel = filepath
    .replace(/^content\/pages/, "")
    .replace(/\/page\.mdx$/, "");
  return rel === "" ? "/" : rel;
}

// ---- MAIN ----

async function build() {
  const files = glob.sync(`${CONTENT_DIR}/*/**/page.mdx`);
  const docs = [];

  for (const file of files) {
    const content = await fs.readFile(file, "utf8");
    const { data, content: mdxBody } = matter(content);

    if (data.draft) continue;

    const allTextParts = extractAllText(data.blocks || {});
    allTextParts.push(mdxBody);
    const combinedText = allTextParts.join(" ");

    const chunks = chunkText(combinedText);
    const slug = pathToSlug(file);
    const title = data.title || path.basename(slug);

    chunks.forEach((chunk, i) => {
      docs.push({
        title,
        slug,
        chunkIndex: i,
        text: chunk,
      });
    });
  }

  console.log(`Indexed ${docs.length} chunks from ${files.length} posts`);

  // Build Fuse index
  const fuseIndex = Fuse.createIndex(KEYS, docs);

  // Save compact form
  const output = {
    keys: KEYS,
    index: fuseIndex.toJSON(),
    docs,
  };

  await fs.outputJson(OUTPUT_FILE, output, { spaces: 0 });
  console.log(`âœ… Search index written to ${OUTPUT_FILE}`);
}

build().catch(console.error);
