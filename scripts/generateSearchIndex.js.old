import fs from "fs";
import path from "path";
import glob from "fast-glob";
import matter from "gray-matter";
import Fuse from "fuse.js";

/**
 * Recursively extracts all string values from any object.
 * This walks arrays, nested objects, etc., and joins all found text.
 */
function extractText(data) {
  if (typeof data === "string") return data;
  if (Array.isArray(data)) return data.map(extractText).join(" ");
  if (data && typeof data === "object")
    return Object.values(data).map(extractText).join(" ");
  return "";
}

const PAGES_ROOT = "content/pages";
const BLOG_ROOT = "content/pages/blog";
const OUTPUT_DIR = "public";

async function generateSearchIndex() {
  const files = await glob(`${BLOG_ROOT}/*/**/page.mdx`);

  const pages = files.map((file) => {
    const raw = fs.readFileSync(file, "utf8");
    const { data, content } = matter(raw);

    // Flatten frontmatter (YAML) text
    const metaText = extractText(data);

    // Combine all text sources: frontmatter + MDX body
    const fullText = `${metaText} ${content}`;

    const folder = path.dirname(file);
    const relative = path.relative(PAGES_ROOT, folder);
    const url = `/${relative}`;

    return {
      id: url,
      title: data.title ?? path.basename(folder),
      url,
      text: fullText,
    };
  });

  const fuseOptions = {
    includeScore: false,
    keys: [
      { name: "title", weight: 0.3 },
      { name: "text", weight: 0.7 },
    ],
  };

  const fuse = new Fuse(pages, fuseOptions);
  const index = fuse.getIndex();

  // Minimal metadata for display
  const meta = pages.map(({ id, title, url }) => ({ id, title, url }));

  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  fs.writeFileSync(
    `${OUTPUT_DIR}/posts-meta.json`,
    JSON.stringify(meta, null, 2)
  );
  fs.writeFileSync(
    `${OUTPUT_DIR}/search-index.json`,
    JSON.stringify(index.toJSON())
  );

  console.log(`âœ… Search index built for ${pages.length} pages`);
}

generateSearchIndex();
